<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="d3-3d.js"></script>
<body>

<form name="filter_input">
     <input name="Submit"  type="button" onclick="filterBeads()" >
     <input type="text" id="filter_id" placeholder="particle ID to filter&hellip;">
</form>

<p id="cur_filters_text"></p>

<svg width="1900" height="1200"></svg>
<script>

    var data    = [], min = max = 500;
    var origin  = [860, 520], startAngle = Math.PI/8, beta = startAngle;
    var svg     = d3.select('svg').call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g');
    var color   = d3.scaleOrdinal(d3.schemeCategory10);
    var rn      = function(min, max){ return Math.round(d3.randomUniform(min, max+1)()); };
    var mx, mouseX;
    var filter_list = [ ]; // list of beads that we don't want shown

   // function used to filter a bead type
   function filterBeads(event) {
     var filter_id = document.getElementById("filter_id").value;
     var i = filter_list.length;
     while(i--) {
        if(filter_id == filter_list[i]) {
           console.log("removing filter for particle type "+filter_id);
           filter_list.splice(i, 1);
           renderFilterList(filter_id);
           return;
        }
     }
     console.log("Adding filter for particle type "+ filter_id);
     filter_list.push(filter_id);
     renderFilterList();
     return;
   }

   // maintains a list of filters on the page
   function renderFilterList(filter_id){
      // clear the text
      d3.select("p").text("");
      // create filter text string
      var filter_string = "";
      if(filter_list.length != 0) {
         filter_string = "Filtering: ";
      }
      for(var i=0; i<filter_list.length; i++) {
         filter_string = filter_string + " " + filter_list[i];
      }
      var p = d3.select("p")
                .text(filter_string);
   }

    function getNewData(jsonfile) {
        p_pos = [];
        var request = new XMLHttpRequest();
        request.open("GET", jsonfile, false);
        request.send(null)
        var JSON_object = JSON.parse(request.responseText);
        var particles = JSON_object.particles;
        for(var i = 0; i<particles.length; i++) {
            p_pos.push({
               x: Math.round(particles[i].x*100.0) - max,
               y: Math.round(particles[i].y*100.0) - max,
               z: Math.round(particles[i].z*100.0) - max,
               id: particles[i].id,
               type: particles[i].type
             });
             //console.log(data[i]);
        }
        return p_pos;
    }

    // beadFiltered(beadId) this returns true if the bead ID is in the filter list
    function beadFilter(bead_type){
      for(var i=0; i<filter_list.length; i++) {
           if(bead_type == filter_list[i])
              return true;
      } 
      return false;
    }

    data = getNewData("state.json");

    var universe_scale=2.0;
    var bead_scale=1.5;

    var _3d = d3._3d()
        .scale(1/universe_scale)
        .origin(origin)
        .rotateX(startAngle)
        .rotateY(startAngle)
        .primitiveType('POINTS');


    var data3D  = _3d(data);
    var extentZ = d3.extent(data3D, function(d){ return d.rotated.z });
    var zScale  = d3.scaleLinear().domain([extentZ[1]+10, extentZ[0]-10]).range([1, 8]);

    // ------------------- auto rotate -------------------------
    // code to slowly rotate the cube of particles
    //var autorotate = setInterval( autorotater, 20 ); // rotate it a bit every 250ms?
    function autorotater() {
        beta -= 0.001;
        processData(_3d.rotateY(beta + startAngle)(data));
    } 


    // ---------------------- web sockets ----------------------
    const socket = new WebSocket('ws://localhost:8079');

    socket.onmessage = function (evt) {
        // update the particle position
        //var d = JSON.parse(evt.data);
        //for(var i=0; i<data.length; i++) {
        //     if (data[i].id == d.id) {
        //         //console.log("updating pos for point"+d.id);
        //         data[i].x = Math.round(d.x);
        //         data[i].y = Math.round(d.y);
        //         data[i].z = Math.round(d.z);
        //         data3D = _3d(data);
        //         processData(data3D);
        //         return;
        //     }
        //}
        //console.log("ERROR: could not find a particle with id: "+d.id);
        if(evt.data == "update") {
            var tmp = getNewData("state.json");
            for(var i=0; i<tmp.length; i++) {
                for(var j=0; j<data.length; j++){
                   if(data[i].id == tmp[i].id) {
                      data[i].x = Math.round(tmp[i].x);
                      data[i].y = Math.round(tmp[i].y);
                      data[i].z = Math.round(tmp[i].z);
                   }
                }
            }
            data3D = _3d(data);
            processData(data3D);
        } else {
          console.log("Error: we recvd a command other than update: "+evt.data);
        }
    }

    // ---------------------- /web sockets ----------------------


    // some rough stuff to find the center of the particles
    //for(var j=0; j<vx.length; j++) {
    //   var vx_sum = vx_sum + vx[j];
    //   var vy_sum = vy_sum + vy[j];
    //   var vz_sum = vz_sum + vz[j];
    //}
    //var vx_avg = Math.round(vx_sum/vx.length);
    //var vy_avg = Math.round(vy_sum/vy.length);
    //var vz_avg = Math.round(vz_sum/vz.length);

    function dragStart(){
        mx = d3.event.x;
    }

    function dragged(){
        mouseX = mouseX || 0;
        beta   = (d3.event.x - mx + mouseX) * Math.PI / 360 * (-1);
        processData(_3d.rotateY(beta + startAngle)(data));
    }

    function dragEnd(){
        mouseX = d3.event.x - mx + mouseX;
    }

    function processData(data){

        var points = svg.selectAll('circle').data(data);

        points
            .enter()
            .append('circle')
            .merge(points)
            .attr('fill',   function(d, i){  
                                           if(beadFilter(d.type)) {
                                             return "none";
                                            } else {
                                             return color(d.type); 
                                            }
                                           })
            .attr('stroke', function(d, i){ return d3.color(color(d.type)).darker(0.5); })
            //.attr('fill',   function(d) {return color(d.type);})
            //.attr('stroke', function(d) {return color(d.type);})
            .sort(function(a, b){    return d3.descending(a.rotated.z, b.rotated.z); })
            .attr('cx', function(d){ return d.projected.x; })
            .attr('cy', function(d){ return d.projected.y; })
            .attr('r' , function(d){ return 2.22*bead_scale*zScale(d.rotated.z); });

        points.exit().remove();
    }

    processData(data3D);
</script>
</body>
